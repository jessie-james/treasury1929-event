# REPLIT AI AGENT: CRITICAL BUG FIX INSTRUCTIONS

## IMMEDIATE PRIORITY: Fix Venue Table Separation Issue

### Problem Statement
Event 13 ("Candlelight Opera") API returns 83 tables for Mezzanine venue instead of expected 13 tables. Tables from both venues (Mezzanine: 13 tables, Main Floor: 70 tables) are mixing in the response.

### ROOT CAUSE ANALYSIS REQUIRED

**Step 1: Add Debug Logging to API Endpoint**
In `server/routes.ts` lines 3505-3601, enhance the venue layouts endpoint:

```typescript
app.get("/api/events/:eventId/venue-layouts", async (req, res) => {
  try {
    const eventId = parseInt(req.params.eventId);
    
    // Add comprehensive logging
    console.log(`ðŸ” DEBUGGING EVENT ${eventId} VENUE LAYOUTS`);
    
    const eventVenuesList = await db
      .select({
        id: eventVenues.id,
        eventId: eventVenues.eventId,
        venueId: eventVenues.venueId,
        displayName: eventVenues.displayName,
        displayOrder: eventVenues.displayOrder,
        venue: {
          id: venues.id,
          name: venues.name,
          width: venues.width,
          height: venues.height,
        }
      })
      .from(eventVenues)
      .leftJoin(venues, eq(eventVenues.venueId, venues.id))
      .where(and(
        eq(eventVenues.eventId, eventId),
        eq(eventVenues.isActive, true)
      ))
      .orderBy(eventVenues.displayOrder);

    console.log(`ðŸ“‹ Found ${eventVenuesList.length} event-venue relationships:`, 
      eventVenuesList.map(ev => ({ 
        venueId: ev.venueId, 
        displayName: ev.displayName 
      }))
    );

    // CRITICAL: Add validation before Promise.all
    const venueLayouts = await Promise.all(
      eventVenuesList.map(async (eventVenue, index) => {
        const venueId = eventVenue.venueId;
        
        console.log(`\nðŸ¢ PROCESSING VENUE ${index + 1}/${eventVenuesList.length}:`);
        console.log(`   Venue ID: ${venueId}`);
        console.log(`   Display Name: ${eventVenue.displayName}`);
        
        // Add explicit query logging
        console.log(`   Executing query: SELECT * FROM tables WHERE venue_id = ${venueId}`);
        
        const venueTables = await db
          .select()
          .from(tables)
          .where(eq(tables.venueId, venueId));
          
        console.log(`   âœ… Query returned ${venueTables.length} tables for venue ${venueId}`);
        console.log(`   Table IDs: ${venueTables.map(t => t.id).join(', ')}`);
        
        // Add table validation
        const invalidTables = venueTables.filter(table => table.venueId !== venueId);
        if (invalidTables.length > 0) {
          console.error(`   âŒ CONTAMINATION DETECTED: ${invalidTables.length} tables belong to wrong venue!`);
          console.error(`   Invalid tables:`, invalidTables.map(t => ({ id: t.id, venueId: t.venueId })));
        }

        const venueStages = await db
          .select()
          .from(stages)
          .where(eq(stages.venueId, venueId));

        const result = {
          eventVenueId: eventVenue.id,
          displayName: eventVenue.displayName,
          displayOrder: eventVenue.displayOrder,
          venue: {
            id: eventVenue.venue.id,
            name: eventVenue.venue.name,
            width: eventVenue.venue.width || 1000,
            height: eventVenue.venue.height || 700
          },
          tables: venueTables.map(table => ({
            id: table.id,
            tableNumber: table.tableNumber,
            venueId: table.venueId, // Add this for validation
            x: table.x,
            y: table.y,
            width: table.width,
            height: table.height,
            capacity: table.capacity,
            shape: table.shape,
            rotation: table.rotation || 0,
            status: 'available'
          })),
          stages: venueStages.map(stage => ({
            id: stage.id,
            x: stage.x,
            y: stage.y,
            width: stage.width,
            height: stage.height,
            rotation: stage.rotation || 0
          }))
        };
        
        console.log(`   ðŸ“Š Final result for ${eventVenue.displayName}: ${result.tables.length} tables`);
        return result;
      })
    );

    console.log(`\nðŸŽ¯ FINAL API RESPONSE SUMMARY:`);
    venueLayouts.forEach((layout, index) => {
      console.log(`   Venue ${index + 1}: ${layout.displayName} - ${layout.tables.length} tables`);
    });

    res.json(venueLayouts);
  } catch (error) {
    console.error("âŒ Error fetching event venue layouts:", error);
    res.status(500).json({ error: "Failed to fetch venue layouts" });
  }
});
```

**Step 2: Database Integrity Check**
Add this diagnostic endpoint to verify data integrity:

```typescript
// Add this temporary diagnostic endpoint
app.get("/api/debug/venue-tables/:eventId", async (req, res) => {
  try {
    const eventId = parseInt(req.params.eventId);
    
    // Get all venues for this event
    const eventVenuesList = await db
      .select()
      .from(eventVenues)
      .leftJoin(venues, eq(eventVenues.venueId, venues.id))
      .where(eq(eventVenues.eventId, eventId));
    
    // Get ALL tables for these venues with explicit venue information
    const allTablesQuery = await db
      .select({
        tableId: tables.id,
        tableNumber: tables.tableNumber,
        venueId: tables.venueId,
        venueName: venues.name,
        eventVenueDisplayName: eventVenues.displayName
      })
      .from(tables)
      .leftJoin(venues, eq(tables.venueId, venues.id))
      .leftJoin(eventVenues, and(
        eq(eventVenues.venueId, tables.venueId),
        eq(eventVenues.eventId, eventId)
      ))
      .where(
        inArray(tables.venueId, eventVenuesList.map(ev => ev.venueId))
      );
    
    // Group by venue for analysis
    const venueTableCounts = allTablesQuery.reduce((acc, table) => {
      const key = `${table.venueId}-${table.venueName}`;
      if (!acc[key]) {
        acc[key] = { count: 0, tables: [] };
      }
      acc[key].count++;
      acc[key].tables.push({
        id: table.tableId,
        number: table.tableNumber,
        displayName: table.eventVenueDisplayName
      });
      return acc;
    }, {} as Record<string, { count: number; tables: any[] }>);
    
    res.json({
      eventId,
      totalEventVenues: eventVenuesList.length,
      venueBreakdown: venueTableCounts,
      allTables: allTablesQuery
    });
    
  } catch (error) {
    console.error("Debug query failed:", error);
    res.status(500).json({ error: "Debug query failed" });
  }
});
```

**Step 3: Frontend Validation Enhancement**
In `client/src/components/booking/IframeSeatSelection.tsx`, add response validation:

```typescript
// Add this validation function
const validateApiResponse = (eventVenueLayouts: any[]) => {
  console.log('ðŸ” VALIDATING API RESPONSE');
  
  eventVenueLayouts.forEach((layout, index) => {
    console.log(`\nVenue ${index + 1}: ${layout.displayName}`);
    console.log(`  Venue ID: ${layout.venue.id}`);
    console.log(`  Table count: ${layout.tables.length}`);
    
    // Check for table contamination
    const wrongVenueTables = layout.tables.filter(
      (table: any) => table.venueId && table.venueId !== layout.venue.id
    );
    
    if (wrongVenueTables.length > 0) {
      console.error(`  âŒ CONTAMINATION: ${wrongVenueTables.length} tables belong to wrong venue!`);
      console.error(`  Wrong tables:`, wrongVenueTables.map((t: any) => ({ 
        id: t.id, 
        correctVenue: layout.venue.id, 
        actualVenue: t.venueId 
      })));
    } else {
      console.log(`  âœ… All tables properly isolated`);
    }
  });
};

// Update the query to include validation
const { data: eventVenueLayouts, isLoading: isLoadingVenues, error: venueError } = useQuery({
  queryKey: [`/api/events/${eventId}/venue-layouts`],
  enabled: !!eventId,
  retry: 1,
  onSuccess: (data) => {
    if (data && Array.isArray(data)) {
      validateApiResponse(data);
    }
  }
});
```

**Step 4: Emergency Fallback Query**
If the issue persists, implement this alternative query approach:

```typescript
// Alternative venue-specific query method
const getVenueTablesAlternative = async (venueId: number) => {
  console.log(`ðŸ”„ ALTERNATIVE QUERY for venue ${venueId}`);
  
  // Use raw SQL if ORM is causing issues
  const result = await db.execute(
    sql`SELECT * FROM tables WHERE venue_id = ${venueId} ORDER BY table_number`
  );
  
  console.log(`   Raw SQL returned ${result.length} rows`);
  return result;
};
```

## TESTING PROTOCOL

1. **Test the diagnostic endpoint**: `GET /api/debug/venue-tables/13`
2. **Check server logs** when accessing the booking page
3. **Verify database directly**: 
   ```sql
   SELECT venue_id, COUNT(*) FROM tables WHERE venue_id IN (3, 4) GROUP BY venue_id;
   ```
4. **Test venue switching** to ensure clean separation

## EXPECTED OUTCOME

After implementing these fixes:
- Mezzanine venue should return exactly 13 tables
- Main Floor venue should return exactly 70 tables
- No table contamination between venues
- Clean venue switching in the UI

## ADDITIONAL IMPROVEMENTS

**Performance Optimization:**
```typescript
// Replace Promise.all with optimized JOIN query
const venueLayoutsOptimized = await db
  .select({
    eventVenueId: eventVenues.id,
    displayName: eventVenues.displayName,
    displayOrder: eventVenues.displayOrder,
    venueId: venues.id,
    venueName: venues.name,
    venueWidth: venues.width,
    venueHeight: venues.height,
    tableId: tables.id,
    tableNumber: tables.tableNumber,
    tableX: tables.x,
    tableY: tables.y,
    // ... other table fields
  })
  .from(eventVenues)
  .leftJoin(venues, eq(eventVenues.venueId, venues.id))
  .leftJoin(tables, eq(tables.venueId, venues.id))
  .where(and(
    eq(eventVenues.eventId, eventId),
    eq(eventVenues.isActive, true)
  ))
  .orderBy(eventVenues.displayOrder, tables.tableNumber);

// Then group the results by venue
const groupedLayouts = venueLayoutsOptimized.reduce((acc, row) => {
  // Grouping logic here
}, {});
```

**Error Boundaries:**
```typescript
// Add to React component
if (venueError) {
  console.error('Venue loading error:', venueError);
  return <div>Error loading venue data. Please refresh.</div>;
}

if (!eventVenueLayouts || eventVenueLayouts.length === 0) {
  return <div>No venues configured for this event.</div>;
}
```

## PRIORITY ORDER
1. âœ… Add debug logging (Step 1)
2. âœ… Test diagnostic endpoint (Step 2) 
3. âœ… Validate frontend response (Step 3)
4. âœ… Implement alternative query if needed (Step 4)
5. âœ… Performance optimization (after bug fix)

Execute these changes and report back with the server log output when accessing the booking page for Event 13.